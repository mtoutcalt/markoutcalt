<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Texas Hold'em Poker - Dazzle Edition Plus Pro</title>
  <!-- Google Font for a modern look -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet">
  <style>
    /* --- Reset & Base Styles --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #0b6623, #004d00);
      font-family: 'Roboto', sans-serif;
      color: #fff;
      overflow: hidden;
      transition: background 0.5s;
    }
    /* --- Alternative Colorblind Mode (toggle via JS adding .colorblind to body) --- */
    body.colorblind {
      background: linear-gradient(135deg, #333399, #222266);
    }
    /* --- Canvas & Animation --- */
    canvas {
      display: block;
      margin: 20px auto;
      background: transparent;
      border: 3px solid #fff;
      border-radius: 10px;
      animation: pulseBorder 3s infinite;
    }
    @keyframes pulseBorder {
      0%   { border-color: #fff; }
      50%  { border-color: #ffd700; }
      100% { border-color: #fff; }
    }
    /* --- Overlay Styles for Menu, Help & Settings --- */
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      text-align: center;
      padding: 20px;
      transition: opacity 0.3s;
    }
    .overlay h1 {
      font-size: 48px;
      margin-bottom: 20px;
    }
    .overlay p {
      max-width: 600px;
      margin: 10px auto;
      line-height: 1.5;
    }
    /* --- Button & Control Styles --- */
    button, input[type="range"] {
      font-size: 16px;
      padding: 10px 20px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      transition: transform 0.2s, background-color 0.2s;
      margin: 5px;
    }
    button {
      background-color: #004d00;
      color: #fff;
    }
    button:hover {
      background-color: #006600;
      transform: scale(1.03);
    }
    button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    /* --- Control Panel Using Flexbox --- */
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }
    /* --- Raise Control --- */
    #raiseControl {
      text-align: center;
      margin: 10px auto;
      display: none;
    }
    #raiseControl input[type="range"] {
      width: 300px;
    }
    /* --- Betting History Log --- */
    #betHistory {
      max-height: 150px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      margin: 10px auto;
      width: 90%;
      border-radius: 4px;
      font-size: 14px;
    }
    #betHistory p {
      margin: 5px 0;
    }
    /* --- Volume & Settings Control --- */
    #volumeControl, #settingsControl {
      display: inline-flex;
      align-items: center;
      margin-left: 20px;
    }
    /* --- Settings Overlay Specific --- */
    #settingsOverlay {
      display: none;
      flex-direction: column;
      gap: 15px;
    }
    #settingsOverlay label {
      font-size: 18px;
    }
  </style>
</head>
<body>
  <!-- Start/Restart Menu Overlay -->
  <div id="menuOverlay" class="overlay">
    <h1>Texas Hold'em Poker</h1>
    <button id="startGameButton">Start Game</button>
    <button id="tournamentToggle">Tournament Mode: Off</button>
    <button id="settingsButton">Settings</button>
  </div>
  <!-- Help/Tutorial Overlay -->
  <div id="helpOverlay" class="overlay" style="display: none;">
    <h1>How to Play</h1>
    <p>
      Welcome to Texas Hold'em Poker – Dazzle Edition Plus Pro!<br /><br />
      • Each hand begins with blinds and two cards are dealt to each player.<br />
      • Betting rounds occur after the flop, turn, and river.<br />
      • Use the Fold, Call, or Raise buttons (or their keyboard shortcuts) to play your hand.<br />
      • Your goal is to win the pot by having the best five‐card hand.<br />
      • You can switch themes, toggle colorblind mode, and adjust sound in Settings.<br />
      • The game ends when you lose all your chips or reach $1000 (or win the tournament in Tournament Mode).
    </p>
    <button id="closeHelp">Close</button>
  </div>
  <!-- Settings Overlay -->
  <div id="settingsOverlay" class="overlay">
    <h1>Settings</h1>
    <div>
      <label for="themeSelect">Choose Table Theme:</label>
      <select id="themeSelect">
        <option value="classic">Classic Green</option>
        <option value="blue">Blue Velvet</option>
        <option value="dark">Dark Mode</option>
      </select>
    </div>
    <div>
      <label>
        <input type="checkbox" id="colorblindToggle"> Enable Colorblind Mode
      </label>
    </div>
    <div id="volumeControl">
      Volume: <input type="range" id="musicVolume" min="0" max="1" step="0.05" value="0.5">
    </div>
    <button id="closeSettings">Close Settings</button>
  </div>

  <!-- Game Canvas -->
  <canvas id="gameCanvas" width="1000" height="700"></canvas>
  
  <!-- Control Panel -->
  <div id="controls">
    <button id="foldButton">Fold</button>
    <button id="callButton">Call</button>
    <button id="raiseButton">Raise</button>
    <button id="nextButton">Next</button>
    <button id="resetScore">Reset Scoreboard</button>
    <button id="musicToggle">Toggle Music</button>
    <button id="helpButton">Help</button>
  </div>
  <!-- Raise Amount Slider Control -->
  <div id="raiseControl">
    <label for="raiseAmount">Select Raise Amount: $<span id="raiseValue">0</span></label><br />
    <input type="range" id="raiseAmount" min="0" max="100" step="5" value="0"><br />
    <button id="confirmRaise">Confirm Raise</button>
    <button id="cancelRaise">Cancel</button>
  </div>
  <!-- Betting History Log -->
  <div id="betHistory"></div>
  <!-- Audio Elements -->
  <audio id="cardSound" src="https://www.soundjay.com/cards/card-deal-1.mp3"></audio>
  <audio id="chipSound" src="https://www.soundjay.com/misc/cash-register-01.mp3"></audio>
  <audio id="winSound" src="https://www.soundjay.com/misc/applause-8.mp3"></audio>
  <audio id="clickSound" src="https://www.soundjay.com/button/sounds/button-16.mp3"></audio>
  <audio id="bgMusic" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" loop></audio>

  <script>
    /*******************************
     * 1. Configuration & Globals  *
     *******************************/
    const config = {
      startingChips: 100,
      winTarget: 1000,
      smallBlind: 5,
      bigBlind: 10,
      minRaiseIncrement: 10,
      canvasWidth: 1000,
      canvasHeight: 700,
      card: { width: 70, height: 100 },
      animationSpeed: 0.03,
      chipAnimationDuration: 1000,
      particleCount: 150,
      bgMusicVolume: 0.5,
      tournamentMode: false // Toggle tournament mode
    };

    // Settings (theme, colorblind, etc.)
    const settings = {
      theme: 'classic', // classic, blue, dark
      colorblind: false
    };

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let CANVAS_WIDTH = canvas.width;
    let CANVAS_HEIGHT = canvas.height;
    const CARD_WIDTH = config.card.width, CARD_HEIGHT = config.card.height;
    const deckPosition = { x: CANVAS_WIDTH / 2 - CARD_WIDTH / 2, y: 40 };

    let scoreboard = { wins: 0, losses: 0, tournamentWins: 0 };
    let playerChips = config.startingChips;
    let dealerIndex = 0;
    let firstHand = true;
    let gameOver = false;

    // Audio elements
    const cardSound = document.getElementById("cardSound");
    const chipSound = document.getElementById("chipSound");
    const winSound = document.getElementById("winSound");
    const clickSound = document.getElementById("clickSound");
    const bgMusic = document.getElementById("bgMusic");
    let musicOn = true;
    bgMusic.volume = config.bgMusicVolume;

    // Tournament mode variables (if enabled)
    let tournamentRound = 1;
    let tournamentHistory = [];

    // Game state object
    let gameState = {
      phase: "preflop",
      pot: 0,
      currentBet: config.bigBlind,
      communityCards: [],
      deck: [],
      message: "Dealing new hand...",
      waitingForPlayer: false,
      dealing: false,
      chipAnim: null,
      particles: [],
      cardAnimations: [],
      // For replay mode (future expansion)
      actionLog: []
    };

    // AI Profiles for advanced CPU opponents
    const aiProfiles = [
      { name: "Player 1", aggression: 0.7 },
      { name: "Player 2", aggression: 0.5 },
      { name: "Player 3", aggression: 0.3 }
    ];

    // --- Deck Definitions ---
    const suits = ["♠", "♥", "♦", "♣"];
    const ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    const rankValues = {
      "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7,
      "8": 8, "9": 9, "10": 10, "J": 11, "Q": 12, "K": 13, "A": 14
    };

    /*********************************
     * 2. Utility Functions & Easing *
     *********************************/
    function createDeck() {
      let deck = [];
      suits.forEach(suit => {
        ranks.forEach(rank => {
          deck.push({ rank, suit, value: rankValues[rank] });
        });
      });
      return deck;
    }
    function shuffle(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }
    // Easing function (easeOutCubic)
    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    /******************************
     * 3. Responsive Canvas Setup *
     ******************************/
    function resizeCanvas() {
      const ratio = config.canvasWidth / config.canvasHeight;
      let newWidth = window.innerWidth * 0.9;
      let newHeight = newWidth / ratio;
      if (newHeight > window.innerHeight * 0.8) {
        newHeight = window.innerHeight * 0.8;
        newWidth = newHeight * ratio;
      }
      canvas.width = newWidth;
      canvas.height = newHeight;
      CANVAS_WIDTH = newWidth;
      CANVAS_HEIGHT = newHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    /***************************
     * 4. Classes & Data Models *
     ***************************/
    class Player {
      constructor(name, isHuman, aiProfile = null) {
        this.name = name;
        this.isHuman = isHuman;
        this.hand = [];
        this.active = true;
        this.bet = 0;
        this.action = "";
        this.bestHand = null;
        // For advanced AI behavior
        this.aiProfile = aiProfile;
      }
    }
    let players = [
      new Player("You", true),
      new Player(aiProfiles[0].name, false, aiProfiles[0]),
      new Player(aiProfiles[1].name, false, aiProfiles[1]),
      new Player(aiProfiles[2].name, false, aiProfiles[2])
    ];

    // Function to draw the dealer button indicator
    function drawDealerButton(x, y) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, 2 * Math.PI);
      ctx.fillStyle = "#FFD700"; // Gold color for dealer button
      ctx.fill();
      ctx.fillStyle = "#000";
      ctx.font = "bold 16px Roboto";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("D", x, y);
      ctx.restore();
    }

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4 - 2;
        this.alpha = 1;
        this.size = Math.random() * 3 + 2;
        this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= 0.02;
      }
      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    function spawnParticles(x, y, count) {
      for (let i = 0; i < count; i++) {
        gameState.particles.push(new Particle(x, y));
      }
    }

    /******************************
     * 5. Drawing Functions & Animations *
     ******************************/
    // Apply theme based on settings
    function applyTheme() {
      const theme = settings.theme;
      switch(theme) {
        case "blue":
          document.body.style.background = "linear-gradient(135deg, #001f3f, #003366)";
          break;
        case "dark":
          document.body.style.background = "linear-gradient(135deg, #111, #333)";
          break;
        default:
          document.body.style.background = "linear-gradient(135deg, #0b6623, #004d00)";
      }
    }
    // Draw table with animated radial gradient background
    function drawTable() {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      // Animated Radial Gradient Background
      let grad = ctx.createRadialGradient(
        CANVAS_WIDTH / 2,
        CANVAS_HEIGHT / 2,
        100,
        CANVAS_WIDTH / 2,
        CANVAS_HEIGHT / 2,
        Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2.2
      );
      let r1 = Math.floor(50 + 50 * Math.sin(performance.now() * 0.0005));
      let color1 = `rgb(${r1},100,50)`;
      let r2 = Math.floor(20 + 20 * Math.cos(performance.now() * 0.0005));
      let color2 = `rgb(${r2},50,20)`;
      grad.addColorStop(0, color1);
      grad.addColorStop(1, color2);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Draw Table Ellipse
      ctx.fillStyle = "#006600";
      ctx.beginPath();
      ctx.ellipse(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, CANVAS_WIDTH / 2.8, CANVAS_HEIGHT / 2.5, 0, 0, 2 * Math.PI);
      ctx.fill();

      // Draw Deck (if cards remain)
      if (gameState.deck.length > 0) {
        drawCardBack(deckPosition.x, deckPosition.y);
      }

      // Draw Community Cards
      let communityCount = gameState.communityCards.length;
      let startX = CANVAS_WIDTH / 2 - ((CARD_WIDTH + 15) * communityCount) / 2;
      let comY = CANVAS_HEIGHT / 2 - CARD_HEIGHT / 2;
      gameState.communityCards.forEach((card, index) => {
        drawCard(startX + index * (CARD_WIDTH + 15), comY, card);
      });

      // Draw Human Player Cards
      players[0].hand.forEach((card, index) => {
        let pos = { x: CANVAS_WIDTH / 2 - CARD_WIDTH - 10 + index * (CARD_WIDTH + 15), 
                    y: CANVAS_HEIGHT - CARD_HEIGHT - 40 };
        drawCard(pos.x, pos.y, card);
      });

      // Draw CPU Players’ Cards and Info
      const cpuPositions = [
        { x: 50, y: 50 },
        { x: CANVAS_WIDTH - CARD_WIDTH * 2 - 50, y: 50 },
        { x: 50, y: CANVAS_HEIGHT - CARD_HEIGHT - 150 }
      ];
      for (let i = 1; i < players.length; i++) {
        let pos = cpuPositions[i - 1];
        if (gameState.phase === "showdown" || !players[i].active) {
          players[i].hand.forEach((card, idx) => {
            drawCard(pos.x + idx * (CARD_WIDTH + 15), pos.y, card);
          });
          if (gameState.phase === "showdown" && players[i].active && players[i].bestHand) {
            ctx.fillStyle = "#fff";
            ctx.font = "16px Roboto";
            ctx.fillText(getHandName(players[i].bestHand), pos.x, pos.y + CARD_HEIGHT + 20);
          }
        } else {
          drawCardBack(pos.x, pos.y);
          drawCardBack(pos.x + CARD_WIDTH + 15, pos.y);
        }
        ctx.fillStyle = "#fff";
        ctx.font = "18px Roboto";
        ctx.fillText(players[i].name, pos.x, pos.y - 15);
        ctx.fillText(players[i].active ? (players[i].action || "In") : "Folded", pos.x, pos.y - 35);
      }

      // --- Draw Dealer Button ---
      if (dealerIndex === 0) {
        // For the human player, position near the first card
        let dealerX = CANVAS_WIDTH / 2 - CARD_WIDTH - 10;
        let dealerY = CANVAS_HEIGHT - CARD_HEIGHT - 60;
        drawDealerButton(dealerX, dealerY);
      } else {
        // For CPU players, use the same cpuPositions
        let cpuPos = cpuPositions[dealerIndex - 1];
        let dealerX = cpuPos.x + CARD_WIDTH + 20;
        let dealerY = cpuPos.y + 15;
        drawDealerButton(dealerX, dealerY);
      }

      // Draw Animated Card Deals
      gameState.cardAnimations.forEach(anim => drawCardAnimation(anim));

      // Scoreboard Display
      ctx.fillStyle = "#fff";
      ctx.font = "20px Roboto";
      ctx.fillText("Wins: " + scoreboard.wins, CANVAS_WIDTH - 150, CANVAS_HEIGHT - 50);
      ctx.fillText("Losses: " + scoreboard.losses, CANVAS_WIDTH - 150, CANVAS_HEIGHT - 20);
      if(config.tournamentMode) {
        ctx.fillText("Tournament Round: " + tournamentRound, CANVAS_WIDTH/2 - 70, 30);
      }

      // Display Pot
      ctx.font = "bold 22px Roboto";
      const potText = "Pot: $" + gameState.pot;
      const potTextWidth = ctx.measureText(potText).width;
      const potX = CANVAS_WIDTH / 2 - potTextWidth / 2;
      const potY = CANVAS_HEIGHT / 2 - 280;
      ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
      ctx.fillRect(potX - 10, potY - 22, potTextWidth + 20, 30);
      ctx.fillStyle = "#fff";
      ctx.fillText(potText, potX, potY);

      // Display Player Chip Count & Chip Icon
      ctx.fillStyle = "#fff";
      ctx.font = "22px Roboto";
      ctx.fillText("Your Chips: $" + playerChips, 20, CANVAS_HEIGHT - 20);
      drawChip(150, CANVAS_HEIGHT - 50, playerChips);

      // Message Box
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(20, CANVAS_HEIGHT - 100, CANVAS_WIDTH - 40, 40);
      ctx.fillStyle = "#fff";
      ctx.font = "20px Roboto";
      ctx.fillText(gameState.message, 30, CANVAS_HEIGHT - 70);

      // Chip Win Animation (if active)
      if (gameState.chipAnim) {
        drawChip(gameState.chipAnim.x, gameState.chipAnim.y, gameState.pot);
      }
      // Draw Particle Effects (Confetti)
      gameState.particles.forEach(p => p.draw(ctx));
    }
    function drawCard(x, y, card) {
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 5;
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.fillStyle = (card.suit === "♥" || card.suit === "♦") ? "#d00" : "#000";
      ctx.font = "22px Roboto";
      ctx.fillText(card.rank + card.suit, x + 8, y + 30);
      ctx.restore();
    }
    function drawCardBack(x, y) {
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 5;
      ctx.fillStyle = "#333";
      ctx.fillRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.fillStyle = "#fff";
      ctx.font = "18px Roboto";
      ctx.fillText("Poker", x + 10, y + 30);
      ctx.restore();
    }
    function drawChip(x, y, amount) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.fillStyle = "#c00";
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = "#fff";
      ctx.font = "16px Roboto";
      ctx.textAlign = "center";
      ctx.fillText("$" + amount, x, y + 5);
      ctx.restore();
    }
    // Animated Card Dealing with Flip & Easing
    function drawCardAnimation(anim) {
      let p = anim.progress;
      let currentX = anim.startX + (anim.endX - anim.startX) * easeOutCubic(p);
      let currentY = anim.startY + (anim.endY - anim.startY) * easeOutCubic(p);
      let flipScale = 1 - 2 * Math.abs(p - 0.5);
      ctx.save();
      let centerX = currentX + CARD_WIDTH / 2;
      let centerY = currentY + CARD_HEIGHT / 2;
      ctx.translate(centerX, centerY);
      ctx.scale(flipScale, 1);
      ctx.translate(-CARD_WIDTH / 2, -CARD_HEIGHT / 2);
      if (p < 0.5) {
        drawCardBack(0, 0);
      } else {
        drawCard(0, 0, anim.card);
      }
      ctx.restore();
    }

    /***********************************
     * 6. Main Game Loop & Animations  *
     ***********************************/
    function updateAnimations() {
      for (let i = gameState.cardAnimations.length - 1; i >= 0; i--) {
        let anim = gameState.cardAnimations[i];
        anim.progress += config.animationSpeed;
        if (anim.progress >= 1) {
          anim.progress = 1;
          players[anim.playerIndex].hand.push(anim.card);
          gameState.cardAnimations.splice(i, 1);
        }
      }
    }
    function gameLoop() {
      updateAnimations();
      gameState.particles = gameState.particles.filter(p => p.alpha > 0);
      gameState.particles.forEach(p => p.update());
      drawTable();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();

    /****************************
     * 7. Game Logic & Phases   *
     ****************************/
    function startHand() {
      gameState.cardAnimations = [];
      gameState.actionLog = [];
      if (!firstHand) {
        dealerIndex = (dealerIndex + 1) % players.length;
      } else {
        firstHand = false;
      }
      // Determine blinds
      let smallBlindIndex = (dealerIndex + 1) % players.length;
      let bigBlindIndex = (dealerIndex + 2) % players.length;
      gameState.phase = "preflop";
      gameState.pot = 0;
      gameState.currentBet = config.bigBlind;
      gameState.communityCards = [];
      gameState.deck = createDeck();
      shuffle(gameState.deck);
      players.forEach(p => {
        p.hand = [];
        p.active = true;
        p.bet = 0;
        p.action = "";
        p.bestHand = null;
      });
      // Post blinds
      if (smallBlindIndex === 0) {
        playerChips = Math.max(0, playerChips - config.smallBlind);
        players[0].bet = config.smallBlind;
      } else {
        players[smallBlindIndex].bet = config.smallBlind;
      }
      if (bigBlindIndex === 0) {
        playerChips = Math.max(0, playerChips - config.bigBlind);
        players[0].bet = config.bigBlind;
      } else {
        players[bigBlindIndex].bet = config.bigBlind;
      }
      gameState.pot = config.smallBlind + config.bigBlind;
      gameState.message = "Blinds posted. Dealing new hand...";
      gameState.waitingForPlayer = false;
      animateDeal();
      logBet("New hand started. " + gameState.message);
    }
    function animateDeal() {
      gameState.dealing = true;
      let dealOrder = [];
      // Two cards per player
      for (let i = 0; i < 2; i++) {
        players.forEach((p, index) => {
          dealOrder.push({ playerIndex: index });
        });
      }
      let dealIndex = 0;
      function dealNext() {
        if (dealIndex < dealOrder.length) {
          const { playerIndex } = dealOrder[dealIndex];
          let targetIndex = players[playerIndex].hand.length +
                            gameState.cardAnimations.filter(a => a.playerIndex === playerIndex).length;
          let endPos = (playerIndex === 0) 
            ? { x: CANVAS_WIDTH/2 - CARD_WIDTH - 10 + targetIndex * (CARD_WIDTH + 15), 
                y: CANVAS_HEIGHT - CARD_HEIGHT - 40 }
            : ([ 
                { x: 50, y: 50 },
                { x: CANVAS_WIDTH - CARD_WIDTH * 2 - 50, y: 50 },
                { x: 50, y: CANVAS_HEIGHT - CARD_HEIGHT - 150 }
              ])[playerIndex - 1];
          let animation = {
            playerIndex,
            card: gameState.deck.pop(),
            progress: 0,
            startX: deckPosition.x,
            startY: deckPosition.y,
            endX: endPos.x,
            endY: endPos.y
          };
          gameState.cardAnimations.push(animation);
          cardSound.currentTime = 0;
          cardSound.play();
          gameState.actionLog.push(`Dealt card to ${players[playerIndex].name}`);
          dealIndex++;
          setTimeout(dealNext, 150);
        } else {
          gameState.dealing = false;
          gameState.waitingForPlayer = true;
          gameState.message = "New hand! Place your bet: Call, Raise or Fold.";
          updateButtons();
        }
      }
      dealNext();
    }
    function nextPhase() {
      if (gameState.dealing) return;
      if (gameState.phase === "preflop") {
        gameState.communityCards.push(gameState.deck.pop());
        gameState.communityCards.push(gameState.deck.pop());
        gameState.communityCards.push(gameState.deck.pop());
        gameState.phase = "flop";
        gameState.message = "Flop dealt. Place your bet.";
      } else if (gameState.phase === "flop") {
        gameState.communityCards.push(gameState.deck.pop());
        gameState.phase = "turn";
        gameState.message = "Turn dealt. Place your bet.";
      } else if (gameState.phase === "turn") {
        gameState.communityCards.push(gameState.deck.pop());
        gameState.phase = "river";
        gameState.message = "River dealt. Place your bet.";
      } else if (gameState.phase === "river") {
        gameState.phase = "showdown";
        gameState.message = "Showdown! Evaluating hands...";
        setTimeout(showdown, 800);
        return;
      }
      gameState.currentBet = config.bigBlind;
      gameState.waitingForPlayer = true;
      updateButtons();
      logBet("Phase changed: " + gameState.message);
    }
    function playerCall() {
      if (!gameState.waitingForPlayer || gameState.dealing) return;
      if (playerChips < gameState.currentBet) {
        let allInAmount = playerChips;
        players[0].bet += allInAmount;
        gameState.pot += allInAmount;
        playerChips = 0;
        players[0].action = "All In (Call)";
        gameState.message = "You are all in with $" + players[0].bet + ". CPU players are deciding...";
        gameState.waitingForPlayer = false;
        updateButtons();
        logBet("Player goes All In (Call) with $" + players[0].bet);
        setTimeout(simulateCPUActions, 800);
        return;
      }
      playerChips -= gameState.currentBet;
      players[0].bet += gameState.currentBet;
      players[0].action = "Called";
      gameState.pot += gameState.currentBet;
      gameState.message = "You called. CPU players are deciding...";
      gameState.waitingForPlayer = false;
      updateButtons();
      logBet("Player called $" + gameState.currentBet);
      setTimeout(simulateCPUActions, 800);
    }
    function showRaiseControl() {
      const raiseSlider = document.getElementById("raiseAmount");
      const minRaise = gameState.currentBet + config.minRaiseIncrement;
      raiseSlider.min = minRaise;
      raiseSlider.max = playerChips;
      raiseSlider.value = minRaise;
      document.getElementById("raiseValue").textContent = minRaise;
      document.getElementById("raiseControl").style.display = "block";
      gameState.waitingForPlayer = false;
      updateButtons();
    }
    function playerRaise(selectedAmount) {
      if (playerChips < selectedAmount) {
        gameState.message = "Not enough chips to raise!";
        return;
      }
      playerChips -= selectedAmount;
      players[0].bet += selectedAmount;
      players[0].action = playerChips === 0 ? "All In (Raise)" : "Raised";
      gameState.pot += selectedAmount;
      gameState.currentBet = selectedAmount;
      gameState.message = "You raised to $" + gameState.currentBet + ". CPU players are deciding...";
      document.getElementById("raiseControl").style.display = "none";
      updateButtons();
      logBet("Player raised to $" + gameState.currentBet);
      setTimeout(simulateCPUActions, 800);
    }
    function playerFold() {
      if (!gameState.waitingForPlayer || gameState.dealing) return;
      players[0].active = false;
      players[0].action = "Folded";
      gameState.message = "You folded. Hand over.";
      gameState.waitingForPlayer = false;
      updateButtons();
      logBet("Player folded.");
      setTimeout(endHandAfterFold, 1500);
    }
    function endHandAfterFold() {
      checkGameOver();
      if (!gameOver) startHand();
    }

    // --- New helper function to compute CPU hand strength ---
    function getCPUHandStrength(player) {
      // If the hand is not yet dealt (should not happen), return a neutral strength.
      if (player.hand.length < 2) return 0.5;
      const card1 = player.hand[0];
      const card2 = player.hand[1];
      // Normalize the sum of card values (max = 14+14 = 28)
      let score = (card1.value + card2.value) / 28;
      // Bonus for a pair
      if (card1.rank === card2.rank) score += 0.1;
      // Bonus for suited cards
      if (card1.suit === card2.suit) score += 0.05;
      return Math.min(score, 1);
    }

    // --- Enhanced CPU logic ---
    function simulateCPUActions() {
      let phaseThreshold;
      switch (gameState.phase) {
        case "preflop": phaseThreshold = 0.8; break;
        case "flop": phaseThreshold = 0.7; break;
        case "turn": phaseThreshold = 0.6; break;
        case "river": phaseThreshold = 0.5; break;
        default: phaseThreshold = 0.7;
      }
      players.forEach((p, index) => {
        if (!p.isHuman && p.active) {
          setTimeout(() => {
            let decision = Math.random();
            let aggression = p.aiProfile ? p.aiProfile.aggression : 0.5;
            // Use hand strength to adjust decision thresholds:
            let handStrength = getCPUHandStrength(p);
            let adjustedThreshold = phaseThreshold * aggression * handStrength;
            if (decision < adjustedThreshold) {
              // CPU chooses to call
              p.bet += gameState.currentBet;
              p.action = "Called";
              gameState.pot += gameState.currentBet;
              logBet(p.name + " called $" + gameState.currentBet);
            } else if (decision < adjustedThreshold + 0.2 * handStrength && playerChips > gameState.currentBet) {
              // CPU chooses to raise
              let raiseAmount = gameState.currentBet + config.minRaiseIncrement;
              p.bet += raiseAmount;
              p.action = "Raised";
              gameState.pot += raiseAmount;
              gameState.currentBet = raiseAmount;
              logBet(p.name + " raised to $" + gameState.currentBet);
            } else {
              // CPU folds
              p.active = false;
              p.action = "Folded";
              logBet(p.name + " folded.");
            }
          }, 500);
        }
      });
      gameState.message += " Betting round complete. Click Next to continue.";
      updateButtons();
    }

    /***************************
     * 8. Hand Evaluation Code *
     ***************************/
    function evaluateHand(cards) {
      let sorted = cards.slice().sort((a, b) => b.value - a.value);
      let rankCount = {};
      let suitCount = {};
      sorted.forEach(card => {
        rankCount[card.value] = (rankCount[card.value] || 0) + 1;
        suitCount[card.suit] = (suitCount[card.suit] || 0) + 1;
      });
      let flushSuit = null;
      for (let suit in suitCount) {
        if (suitCount[suit] >= 5) { flushSuit = suit; break; }
      }
      let flushCards = flushSuit ? sorted.filter(card => card.suit === flushSuit) : [];
      let uniqueValues = [...new Set(sorted.map(card => card.value))].sort((a, b) => b - a);
      let straightHigh = null;
      for (let i = 0; i <= uniqueValues.length - 5; i++) {
        let seq = true;
        for (let j = 0; j < 4; j++) {
          if (uniqueValues[i+j] - 1 !== uniqueValues[i+j+1]) { seq = false; break; }
        }
        if (seq) { straightHigh = uniqueValues[i]; break; }
      }
      if (!straightHigh && uniqueValues.includes(14) && uniqueValues.includes(5) &&
          uniqueValues.includes(4) && uniqueValues.includes(3) && uniqueValues.includes(2)) {
        straightHigh = 5;
      }
      let straightFlushHigh = null;
      if (flushCards.length >= 5) {
        let uniqueFlush = [...new Set(flushCards.map(card => card.value))].sort((a, b) => b - a);
        for (let i = 0; i <= uniqueFlush.length - 5; i++) {
          let seq = true;
          for (let j = 0; j < 4; j++) {
            if (uniqueFlush[i+j] - 1 !== uniqueFlush[i+j+1]) { seq = false; break; }
          }
          if (seq) { straightFlushHigh = uniqueFlush[i]; break; }
        }
        if (!straightFlushHigh && uniqueFlush.includes(14) && uniqueFlush.includes(5) &&
            uniqueFlush.includes(4) && uniqueFlush.includes(3) && uniqueFlush.includes(2)) {
          straightFlushHigh = 5;
        }
      }
      if (straightFlushHigh) return { rank: 8, highCard: straightFlushHigh, kickers: [] };
      let four = Object.keys(rankCount).find(val => rankCount[val] == 4);
      if (four) {
        four = parseInt(four);
        let kicker = sorted.find(card => card.value !== four).value;
        return { rank: 7, highCard: four, kickers: [kicker] };
      }
      let threes = Object.keys(rankCount).filter(val => rankCount[val] >= 3).map(Number).sort((a, b) => b - a);
      if (threes.length > 0) {
        let pair = Object.keys(rankCount).filter(val => rankCount[val] >= 2 && parseInt(val) !== threes[0]).map(Number).sort((a, b) => b - a);
        if (pair.length > 0) return { rank: 6, highCard: threes[0], kickers: [pair[0]] };
      }
      if (flushCards.length >= 5) {
        return { rank: 5, highCard: flushCards[0].value, kickers: flushCards.slice(1, 5).map(card => card.value) };
      }
      if (straightHigh) return { rank: 4, highCard: straightHigh, kickers: [] };
      if (threes.length > 0) {
        let kickers = sorted.filter(card => card.value !== threes[0]).slice(0, 2).map(card => card.value);
        return { rank: 3, highCard: threes[0], kickers: kickers };
      }
      let pairs = Object.keys(rankCount).filter(val => rankCount[val] == 2).map(Number).sort((a, b) => b - a);
      if (pairs.length >= 2) {
        let kicker = sorted.find(card => card.value !== pairs[0] && card.value !== pairs[1]).value;
        return { rank: 2, highCard: pairs[0], kickers: [pairs[1], kicker] };
      }
      if (pairs.length >= 1) {
        let kickers = sorted.filter(card => card.value !== pairs[0]).slice(0, 3).map(card => card.value);
        return { rank: 1, highCard: pairs[0], kickers: kickers };
      }
      return { rank: 0, highCard: sorted[0].value, kickers: sorted.slice(1, 5).map(card => card.value) };
    }
    function getHandName(handValue) {
      switch (handValue.rank) {
        case 8: return "Straight Flush";
        case 7: return "Four of a Kind";
        case 6: return "Full House";
        case 5: return "Flush";
        case 4: return "Straight";
        case 3: return "Three of a Kind";
        case 2: return "Two Pair";
        case 1: return "One Pair";
        default: return "High Card";
      }
    }
    function compareHands(handA, handB) {
      if (handA.rank !== handB.rank) return handA.rank - handB.rank;
      if (handA.highCard !== handB.highCard) return handA.highCard - handB.highCard;
      for (let i = 0; i < Math.min(handA.kickers.length, handB.kickers.length); i++) {
        if (handA.kickers[i] !== handB.kickers[i]) return handA.kickers[i] - handB.kickers[i];
      }
      return 0;
    }
    // Animate chip win movement with a bounce effect
    function animateChipWin(winner, callback) {
      const duration = config.chipAnimationDuration;
      const startTime = performance.now();
      const startPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 - 280 };
      const chipPositions = [
        { x: 150, y: CANVAS_HEIGHT - 50 },
        { x: CANVAS_WIDTH - 150, y: 50 },
        { x: 150, y: 50 },
        { x: 50, y: CANVAS_HEIGHT - 100 }
      ];
      let winnerIndex = players.indexOf(winner);
      const endPos = chipPositions[winnerIndex];
      function animate(now) {
        let progress = Math.min((now - startTime) / duration, 1);
        let bounce = easeOutCubic(progress);
        gameState.chipAnim = {
          x: startPos.x + (endPos.x - startPos.x) * bounce,
          y: startPos.y + (endPos.y - startPos.y) * bounce
        };
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          gameState.chipAnim = null;
          callback();
        }
      }
      chipSound.currentTime = 0;
      chipSound.play();
      requestAnimationFrame(animate);
    }
    // Showdown: Evaluate hands and declare winner
    function showdown() {
      if (!players[0].active) {
        gameState.message = "You folded. You lose this hand.";
        setTimeout(() => {
          checkGameOver();
          if (!gameOver) startHand();
        }, 2000);
        return;
      }
      let results = [];
      players.forEach(p => {
        if (p.active) {
          let allCards = p.hand.concat(gameState.communityCards);
          let handValue = evaluateHand(allCards);
          p.bestHand = handValue;
          results.push({ player: p, handValue: handValue });
        }
      });
      results.sort((a, b) => compareHands(b.handValue, a.handValue));
      let winner = results[0].player;
      let handName = getHandName(winner.bestHand);
      gameState.message = "Showdown! " + winner.name + " wins with " + handName + " and takes $" + gameState.pot + ".";
      if (winner.isHuman) {
        playerChips += gameState.pot;
        winSound.currentTime = 0;
        winSound.play();
        spawnParticles(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, config.particleCount);
      } else if(config.tournamentMode) {
        tournamentHistory.push({ round: tournamentRound, winner: winner.name, pot: gameState.pot });
      }
      animateChipWin(winner, () => {
        setTimeout(() => {
          checkGameOver();
          if (!gameOver) startHand();
        }, 1500);
      });
      logBet("Showdown: " + winner.name + " wins with " + handName);
    }
    function checkGameOver() {
      if (playerChips <= 0) {
        gameState.message = "Game Over! You lost all your chips.";
        gameOver = true;
        disableAllButtons();
        scoreboard.losses++;
        drawTable();
        showMenu("Game Over! Try Again?");
      } else if (playerChips >= config.winTarget) {
        gameState.message = "Congratulations! You reached $" + config.winTarget + "!";
        gameOver = true;
        disableAllButtons();
        scoreboard.wins++;
        spawnParticles(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, config.particleCount);
        drawTable();
        showMenu("You Win! Play Again?");
      }
    }
    function disableAllButtons() {
      document.getElementById("foldButton").disabled = true;
      document.getElementById("callButton").disabled = true;
      document.getElementById("raiseButton").disabled = true;
      document.getElementById("nextButton").disabled = true;
    }
    function showMenu(message) {
      const overlay = document.getElementById("menuOverlay");
      overlay.innerHTML = "<h1>" + message + "</h1><button id='restartGameButton'>Restart Game</button>";
      overlay.style.display = "flex";
      document.getElementById("restartGameButton").addEventListener("click", () => {
        overlay.style.display = "none";
        gameOver = false;
        playerChips = config.startingChips;
        players.forEach(p => p.hand = []);
        gameState.cardAnimations = [];
        startHand();
      });
    }
    function logBet(message) {
      const logDiv = document.getElementById("betHistory");
      const p = document.createElement("p");
      p.textContent = message;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
      gameState.actionLog.push(message);
    }

    /***********************************
     * 9. UI & Button Event Listeners  *
     ***********************************/
    function updateButtons() {
      if (playerChips === 0) {
        document.getElementById("foldButton").disabled = true;
        document.getElementById("callButton").disabled = true;
        document.getElementById("raiseButton").disabled = true;
        document.getElementById("nextButton").disabled = gameState.dealing;
      } else {
        document.getElementById("foldButton").disabled = !gameState.waitingForPlayer;
        document.getElementById("callButton").disabled = !gameState.waitingForPlayer;
        document.getElementById("raiseButton").disabled = !gameState.waitingForPlayer;
        document.getElementById("nextButton").disabled = gameState.waitingForPlayer || gameState.dealing;
      }
    }
    document.getElementById("foldButton").addEventListener("click", () => { clickSound.play(); playerFold(); });
    document.getElementById("callButton").addEventListener("click", () => { clickSound.play(); playerCall(); });
    document.getElementById("raiseButton").addEventListener("click", () => { clickSound.play(); showRaiseControl(); });
    document.getElementById("nextButton").addEventListener("click", () => { clickSound.play(); nextPhase(); });
    document.getElementById("resetScore").addEventListener("click", () => {
      scoreboard = { wins: 0, losses: 0, tournamentWins: 0 };
    });
    document.getElementById("musicToggle").addEventListener("click", () => {
      if (musicOn) { bgMusic.pause(); musicOn = false; }
      else { bgMusic.play(); musicOn = true; }
    });
    document.getElementById("startGameButton").addEventListener("click", () => {
      document.getElementById("menuOverlay").style.display = "none";
      bgMusic.play();
      startHand();
    });
    document.getElementById("helpButton").addEventListener("click", () => {
      document.getElementById("helpOverlay").style.display = "flex";
    });
    document.getElementById("closeHelp").addEventListener("click", () => {
      document.getElementById("helpOverlay").style.display = "none";
    });
    const raiseSlider = document.getElementById("raiseAmount");
    raiseSlider.addEventListener("input", () => {
      document.getElementById("raiseValue").textContent = raiseSlider.value;
    });
    document.getElementById("confirmRaise").addEventListener("click", () => {
      clickSound.play();
      playerRaise(parseInt(raiseSlider.value));
    });
    document.getElementById("cancelRaise").addEventListener("click", () => {
      document.getElementById("raiseControl").style.display = "none";
      gameState.waitingForPlayer = true;
      updateButtons();
    });
    document.getElementById("settingsButton").addEventListener("click", () => {
      document.getElementById("settingsOverlay").style.display = "flex";
    });
    document.getElementById("closeSettings").addEventListener("click", () => {
      document.getElementById("settingsOverlay").style.display = "none";
    });
    document.getElementById("themeSelect").addEventListener("change", (e) => {
      settings.theme = e.target.value;
      applyTheme();
    });
    document.getElementById("colorblindToggle").addEventListener("change", (e) => {
      settings.colorblind = e.target.checked;
      if (settings.colorblind) document.body.classList.add("colorblind");
      else document.body.classList.remove("colorblind");
    });
    document.getElementById("musicVolume").addEventListener("input", (e) => {
      bgMusic.volume = e.target.value;
    });
    document.getElementById("tournamentToggle").addEventListener("click", () => {
      config.tournamentMode = !config.tournamentMode;
      document.getElementById("tournamentToggle").textContent = "Tournament Mode: " + (config.tournamentMode ? "On" : "Off");
      if(config.tournamentMode) {
        tournamentRound = 1;
        tournamentHistory = [];
        logBet("Tournament Mode Activated. Round " + tournamentRound);
      }
    });

    // --- Enhancement: Keyboard Shortcuts ---
    // Use F (Fold), C (Call), R (Raise), N (Next), H (Help) and Esc (cancel raise control)
    document.addEventListener("keydown", (e) => {
      // Do not interfere if an overlay is visible
      if (document.getElementById("menuOverlay").style.display === "flex" ||
          document.getElementById("settingsOverlay").style.display === "flex" ||
          document.getElementById("helpOverlay").style.display === "flex") {
        return;
      }
      switch (e.key.toLowerCase()) {
        case "f":
          if (!document.getElementById("foldButton").disabled) {
            clickSound.play();
            playerFold();
          }
          break;
        case "c":
          if (!document.getElementById("callButton").disabled) {
            clickSound.play();
            playerCall();
          }
          break;
        case "r":
          if (!document.getElementById("raiseButton").disabled) {
            clickSound.play();
            showRaiseControl();
          }
          break;
        case "n":
          if (!document.getElementById("nextButton").disabled) {
            clickSound.play();
            nextPhase();
          }
          break;
        case "h":
          document.getElementById("helpOverlay").style.display = "flex";
          break;
        case "escape":
          if (document.getElementById("raiseControl").style.display === "block") {
            document.getElementById("raiseControl").style.display = "none";
            gameState.waitingForPlayer = true;
            updateButtons();
          }
          break;
        default:
          break;
      }
    });
  </script>
</body>
</html>
